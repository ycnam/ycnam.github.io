---
date: 2010-03-29T15:41:38+00:00
draft: false
tags: ["C language"]
title: "[C language] about overflow, casting, datatype..."
---
<pre><code>
#include <stdio.h>

int main(void)
{
int x;
int y;
int sum;
int sub;
int mult;
double div;
int remain;

//두 수의 합
x = 100;
y = 200;
sum = x + y;
printf("두 수의 합 (%d + %d) : %d \n\n", x, y, sum);

//두 수의 차
x = 3;
y = 24;
sub = x - y;
printf("두 수의 차 (%d - %d) : %d \n\n", x, y, sub);

//두 수의 곱
x = 4151050;
y = 2010;
mult = x * y;
printf("두 수의 곱 (%d * %d) : %d \n\n", x, y, mult);

//두 수의 나누기
x = 1;
y = 2;
div = (double)x / y;
printf("두 수의 나누기 (%d / %d) : %.1lf \n\n", x, y, div);

//두 수의 나머지
x = 18458;
y = 3;
remain = x % y;
printf("두 수의 나머지값 : %d \n\n", remain);
}
</code></pre>
변수를 이용해서 두 수의 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 구하기를 실습하는 코드.

덧셈과 뺄셈에선 딱히 문제될 것이 없다.

곱셈부터 슬슬 문제가 시작되는데, 위 예제에서 곱셈부분 x, y변수를 곱하면

int 데이터타입의 한계를 넘어서게 된다. (Overflow)

C언어에서 overflow가 발생하면 컴파일 에러를 내지 않는다.

다만 결과값이 이상해지는 논리적 오류만을 가져올 뿐이다.

언제나 그렇듯, 목소리를 내지 않는 에러는 더 위험하다 (삽질 디버깅의 주범).

overflow상황에서 C언어의 변수는 순환구조를 통해 컴파일 에러를 피한다.

예를 들어 AAA라는 데이터타입이 -8부터 8을 표현한다 해보자.

AAA = 8 + 1이면 overflow가 발생한다. 이 때, AAA는 가장 작은 수로 돌아가서

printf("%d", AAA);

이렇게 출력해보면,

-8

을 출력한다.

AAA = 8 + 2 면 AAA는 -7값을 갖는다.

위 예제에서 곱셈을 실행하면 overflow가 발생하고 알 수 없는 음수를 출력한다.

C에서 정수를 나타내는 데이터타입은 short, int, long이 있고,

int는 4바이트로 구성되어있다.

최신 C표준에서 long은 8바이트이나, VC++ 6.0버전에서는 여전히 long도 4바이트로

int와 표현영역이 같다. (턱없이 부족해보인다...)

<em>제일 문제되는 부분은 나눗셈부분이다.</em>

드디어 '실수'의 영역으로 들어가기 때문.

1을 2로 나누면, 정수의 영역을 탈출. 따라서 두 변수의 나눗셈이 들어가는 변수 div는

실수형으로 선언되어야 한다.

실수를 나타내는 변수는 float과 double이 있다.

double은 소수점 영역에서 float의 두배의 정밀도를 가진다.

(float은 소수점아래 6자리까지, double은 12자리까지)

VC++ 6.0의 실수 표준은 double이다.

그냥 '3.0'과 같이 상수 표현식을 써도, double로 인식한다는 말이다.

따라서 일단, 나눗셈의 결과를 받는 div를 double로 선언해본다.

하지만,
<pre><code>div = x / y;

printf("%lf", div);</code></pre>
이걸 실행해보면 0을 출력한다.

이유인즉슨.. x와 y는 둘 다 정수형이고 (int)

정수와 정수의 연산은 무조건 정수를 결과값으로 던지기 때문이다.

0.5라는 결과가 나오지만, 결과값이 정수여야하므로, 소수점 아래를 '버려버린다'

따라서 결과는 0.

0.5라는 수를 얻으려면 x나 y의 데이터타입을 실수형으로 '강제변환'하여

결과값 역시 실수형으로 던지도록 해야한다.

(실수와 정수를 연산하면 실수를 반환한다. 표현범위가 큰 쪽을 따르기 때문이다)

즉 'Casting'이 필요하다는 것.

정수 x를 실수형으로 강제변환하는 것은 다음과 같다.
<pre><code>
div = (double)x / y;
</code></pre>
이렇게 하면 x는 double형으로 강제변환되고, div에는 0.5가 들어가는데..

출력해보면 0.5가 아닌 0.500000000000를 출력한다.

뒤쪽 무의미한 소수점들을 정리하려면

printf의 형식지정자에 특별 숫자를 붙여줘야한다.
<pre><code>
printf("%lf", div);
printf("%.1lf", div);
printf("%.3lf", div);
printf("%3.5lf", div);
</code></pre>
위의 네개의 코드는 각각 다음과 같이 출력한다.
<pre><code>
0.500000000000
0.5
0.500
0.50000
</code></pre>
첫번째 것은 double의 표현영역인 소수점아래 12자리까지 모두 출력하고,

형식지정자에 .1을 붙인 두번째 것은 첫째 자리까지만,

.3을 붙인 세번째 것은 셋째 자리까지,

3.5를 붙인 네번째 것은 다섯째 자리까지 출력한다.

이때 3.5의 3은 소수점 위쪽 자리의 갯수를 의미한다.

여기선 소수점 위로 숫자가 0이므로 무의미..

-

그 외에 printf()와 scanf()에 대한 내용은 앞으로 더 다루리라 생각된다.

다음은 형식지정자에 대한 설명.

%d : 정수를 십진수로 출력
%f : 소수점이 있는 실수 출력
%lf : double 데이터타입규모의 실수 출력
%c : 문자 형태 출력 ('a')
%s : 문자열 형태 출력 ("abc")
